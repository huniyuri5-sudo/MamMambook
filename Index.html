<!doctype html>

<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>오목 대결 · Firebase Realtime DB (매치메이킹 + 레이팅 리더보드 + 관전)</title>
  <style>
    :root{
      --bg:#0f172a; --card:#111827; --muted:#93a6bf; --ring:#38bdf8; --accent:#22d3ee; --danger:#ef4444; --ok:#22c55e;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b1324,#0f172a 35%,#0b1324);font-family:system-ui,Segoe UI,Apple SD Gothic Neo,Pretendard,Arial,sans-serif;color:#e5e7eb}
    header{padding:16px 20px;border-bottom:1px solid #1f2937;background:#0b1324;position:sticky;top:0;z-index:10}
    h1{margin:0;font-size:18px;letter-spacing:.3px}
    .wrap{max-width:1280px;margin:0 auto;padding:20px;display:grid;grid-template-columns:420px 1fr;gap:20px}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .card .hd{padding:14px 16px;border-bottom:1px solid #1f2937;font-weight:600}
    .card .bd{padding:14px 16px}
    label{display:block;font-size:13px;color:var(--muted);margin:8px 0 6px}
    input,button{font:inherit}
    input[type=text]{width:100%;padding:10px 12px;border:1px solid #26405a;border-radius:10px;background:#0b1324;color:#e5e7eb}
    .row{display:flex;gap:8px;align-items:center}
    .row button{flex:1}
    button{cursor:pointer;border:none;padding:10px 12px;border-radius:10px;background:#0e7490;color:#e6f3f9}
    button.sec{background:#374151}
    button.alt{background:#2563eb}
    button:disabled{opacity:.5;cursor:not-allowed}
    .status{font-size:14px;line-height:1.4}
    .status .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #23405a;background:#0b1324;font-size:12px;color:#9ecfe6}
    canvas{background:#f4d9a2;border-radius:12px;display:block;width:100%;height:auto;image-rendering:-webkit-optimize-contrast}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .ok{color:var(--ok)} .danger{color:var(--danger)}
    .log{font-size:12px;color:#9fbad1;max-height:140px;overflow:auto;background:#0b1324;border:1px solid #1f2937;border-radius:10px;padding:8px}
    .timer{display:flex;gap:8px;margin-top:10px}
    .timer .clock{flex:1;background:#0b1324;border:1px solid #1f2937;border-radius:10px;padding:8px}
    .timer .clock h4{margin:0 0 6px 0;font-size:13px;color:#9fbad1}
    .big{font-size:20px;font-weight:700}
    .table{width:100%;border-collapse:collapse;font-size:14px}
    .table th,.table td{border-bottom:1px solid #1f2937;padding:8px;text-align:left}
    .table th{color:#9fbad1;font-weight:600}
  </style>
</head>
<body>
  <header>
    <h1>♟️ 오목 대결 · Firebase (매치메이킹 + 리더보드 + 관전)</h1>
  </header>
  <div class="wrap">
    <section class="card">
      <div class="hd">설정 & 연결</div>
      <div class="bd">
        <div class="grid">
          <div>
            <label>내 UID</label>
            <div id="myUid" class="mono">(로그인 대기)</div>
          </div>
          <div>
            <label>현재 방 ID</label>
            <div id="roomLabel" class="mono">—</div>
          </div>
        </div>
        <label>방 ID</label>
        <div class="row">
          <input id="roomId" type="text" placeholder="예: room-1234" />
          <button id="btnCreate" disabled>방 만들기</button>
        </div>
        <div style="height:8px"></div>
        <div class="row">
          <button id="btnJoin" class="sec" disabled>방 참가</button>
          <button id="btnQuick" class="alt" disabled>빠른 참가</button>
          <button id="btnLeave" class="sec">나가기</button>
        </div>
        <div style="height:10px"></div>
        <div class="status" id="statusBox">
          상태: <span class="pill" id="pill">초기화</span>
          <div style="height:6px"></div>
          <div>역할: <span id="role">—</span> / 돌 색: <span id="color">—</span> / 내 차례? <span id="turnQ">—</span></div>
          <div>호스트: <span id="hostUid" class="mono">—</span></div>
          <div>게스트: <span id="guestUid" class="mono">—</span></div>
        </div>
        <div style="height:12px"></div>
        <div class="log" id="log"></div>
      </div>
    </section><section class="card">
  <div class="hd">대국</div>
  <div class="bd">
    <canvas id="board" width="600" height="600"></canvas>
    <div class="timer">
      <div class="clock" id="clockB"><h4>흑 시간</h4><div class="big" id="timeB">05:00</div></div>
      <div class="clock" id="clockW"><h4>백 시간</h4><div class="big" id="timeW">05:00</div></div>
    </div>
    <div style="height:8px"></div>
    <div class="grid">
      <div>
        <label>내 레이팅</label>
        <div class="mono" id="myRating">—</div>
      </div>
      <div>
        <label>상대 레이팅</label>
        <div class="mono" id="oppRating">—</div>
      </div>
    </div>
  </div>
</section>

<section class="card">
  <div class="hd">레이팅 리더보드 (Top 20)</div>
  <div class="bd">
    <table class="table">
      <thead><tr><th>순위</th><th>UID</th><th>레이팅</th><th>전적</th></tr></thead>
      <tbody id="lbBody"><tr><td colspan="4" style="color:#9fbad1">불러오는 중…</td></tr></tbody>
    </table>
  </div>
</section>

<section class="card">
  <div class="hd">관전 (진행중인 방)</div>
  <div class="bd">
    <div class="row">
      <input id="watchId" type="text" placeholder="방 ID로 관전" />
      <button id="btnWatch" class="alt" disabled>관전 시작</button>
      <button id="btnRefreshWatch" class="sec">목록 새로고침</button>
    </div>
    <div style="height:8px"></div>
    <table class="table">
      <thead><tr><th>방 ID</th><th>흑</th><th>백</th><th>수</th><th>턴</th><th></th></tr></thead>
      <tbody id="watchBody"><tr><td colspan="6" style="color:#9fbad1">목록 불러오기 클릭</td></tr></tbody>
    </table>
  </div>
</section>

  </div>  <!-- Firebase v10 (modular) -->  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
    import { getDatabase, ref, child, set, update, onValue, runTransaction, onDisconnect, serverTimestamp, get, query, orderByChild, equalTo } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";

   const firebaseConfig = {
  apiKey: "AIzaSyCZe6mU-zN_pK1XgdLBXbl9gpiefM1zhT0",
  authDomain: "omok-d5f24.firebaseapp.com",
  databaseURL: "https://omok-d5f24-default-rtdb.firebaseio.com",
  projectId: "omok-d5f24",
  storageBucket: "omok-d5f24.firebasestorage.app",
  messagingSenderId: "913272245831",
  appId: "1:913272245831:web:3ae75841e0e97be832ab62",
  measurementId: "G-F713FYKGT5"
};

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    // ====== DOM ======
    const el = id => document.getElementById(id);
    const myUidEl = el('myUid');
    const roomLabelEl = el('roomLabel');
    const pillEl = el('pill');
    const roleEl = el('role');
    const colorEl = el('color');
    const turnQEl = el('turnQ');
    const hostUidEl = el('hostUid');
    const guestUidEl = el('guestUid');
    const roomIdInput = el('roomId');
    const btnCreate = el('btnCreate');
    const btnJoin = el('btnJoin');
    const btnQuick = el('btnQuick');
    const btnLeave = el('btnLeave');
    const canvas = el('board');
    const logBox = el('log');
    const lbBody = el('lbBody');
    const ctx = canvas.getContext('2d');
    const timeBEl = el('timeB');
    const timeWEl = el('timeW');
    const myRatingEl = el('myRating');
    const oppRatingEl = el('oppRating');
    const watchIdInput = el('watchId');
    const btnWatch = el('btnWatch');
    const btnRefreshWatch = el('btnRefreshWatch');
    const watchBody = el('watchBody');

    // ====== 상태 ======
    const N = 15;                       // 보드 크기
    const CELL = canvas.width / (N + 1);// 여백 포함 간격
    let me = { uid: null };
    let currentRoomId = null;
    let roomUnsub = null;    // onValue off 용
    let presenceRef = null;
    let resultCommittedLocal = false;   // 레이팅 중복 커밋 방지
    let tickTimer = null;               // 시계 표시 타이머
    let spectatorMode = false;          // 관전 모드 on/off

    // 클라이언트 캐시 (스냅샷 병합 시 기본값 보장)
    let gameCache = {
      gameId: null,
      hostUid: null,
      guestUid: null,
      status: 'waiting', // waiting | playing | ended
      turn: 'B',         // 'B' (흑) / 'W' (백)
      winner: null,
      moves: [],
      // 타이머/레이팅
      timeB: 300000, // 5분
      timeW: 300000,
      incMs: 10000,  // 매 수 10초 증가
      lastTurnTs: null,
      resultCommitted: false
    };

    const normMoves = (raw) => {
      if (Array.isArray(raw)) return raw.filter(Boolean);
      if (raw && typeof raw === 'object') return Object.values(raw).filter(Boolean);
      return [];
    };

    const log = (...a)=>{ const s=a.map(x=> typeof x==='string'?x:JSON.stringify(x)).join(' '); logBox.textContent = (s+''+logBox.textContent).slice(0,4000); };

    // ====== 유틸 ======
    const setPill = (text, cls) => { pillEl.textContent = text; pillEl.className = 'pill ' + (cls||''); };
    const myRole = () => spectatorMode ? 'SPECTATOR' : (me.uid && gameCache.hostUid === me.uid) ? 'HOST' : (me.uid && gameCache.guestUid === me.uid) ? 'GUEST' : '-';
    const myColor = () => (myRole()==='HOST') ? 'B' : (myRole()==='GUEST') ? 'W' : '-';
    const isMyTurn = () => !spectatorMode && gameCache.status==='playing' && myColor() === gameCache.turn;

    // ====== 렌더링 ======
    function drawBoard(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#f4d9a2';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.strokeStyle = '#7c5c2c';
      ctx.lineWidth = 1;
      for(let i=1;i<=N;i++){
        ctx.beginPath(); ctx.moveTo(CELL, i*CELL); ctx.lineTo(N*CELL, i*CELL); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(i*CELL, CELL); ctx.lineTo(i*CELL, N*CELL); ctx.stroke();
      }

      const stars = [4,8,12];
      ctx.fillStyle = '#5b4630';
      stars.forEach(r=>stars.forEach(c=>{ ctx.beginPath(); ctx.arc(c*CELL, r*CELL, 3, 0, Math.PI*2); ctx.fill(); }));

      const moves = normMoves(gameCache?.moves);
      for(const m of moves){ if(!m) continue; drawStone(m.x, m.y, m.color); }
    }

    function drawStone(x,y,color){
      const cx = (x+1)*CELL, cy = (y+1)*CELL;
      ctx.beginPath();
      ctx.arc(cx, cy, CELL*0.42, 0, Math.PI*2);
      const grad = ctx.createRadialGradient(cx-4, cy-6, CELL*0.05, cx, cy, CELL*0.45);
      if(color==='B') { grad.addColorStop(0,'#333'); grad.addColorStop(1,'#000'); }
      else { grad.addColorStop(0,'#fff'); grad.addColorStop(1,'#c9c9c9'); }
      ctx.fillStyle = grad; ctx.fill();
      ctx.strokeStyle = '#00000055'; ctx.lineWidth = 1; ctx.stroke();
    }

    function updateStatusUI(){
      roomLabelEl.textContent = currentRoomId ?? '—';
      hostUidEl.textContent = gameCache.hostUid ?? '—';
      guestUidEl.textContent = gameCache.guestUid ?? '—';
      roleEl.textContent = myRole();
      colorEl.textContent = myColor();
      turnQEl.textContent = isMyTurn()? '✅ 네 차례' : (spectatorMode? '👀 관전' : '⏳ 대기');

      if(gameCache.status==='waiting') setPill(spectatorMode?'대기(관전)':'대국 대기','');
      else if(gameCache.status==='playing') setPill(spectatorMode?'진행 중(관전)':'진행 중','ok');
      else if(gameCache.status==='ended') setPill(`종료 (${gameCache.winner? (gameCache.winner==='B'?'흑':'백')+' 승':''})`,'danger');

      drawBoard();
      startOrUpdateTick();
    }

    // 클릭 → 착수 (관전 차단 + 스냅 + 에러 표출 + 타이머 반영)
    canvas.addEventListener('click', async (e)=>{
      try{
        if(currentRoomId==null) return;
        if(spectatorMode){ log('착수 거부: 관전 모드'); return; }
        if(gameCache.status!=='playing') { log('착수 거부: 진행 상태 아님'); return; }
        if(!isMyTurn()) { log('착수 거부: 내 차례 아님'); return; }

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width  / rect.width;
        const scaleY = canvas.height / rect.height;
        const cx = (e.clientX - rect.left) * scaleX;
        const cy = (e.clientY - rect.top)  * scaleY;

        const gx = Math.round(cx / CELL);
        const gy = Math.round(cy / CELL);
        const x = gx - 1;
        const y = gy - 1;
        if (x<0 || x>=N || y<0 || y>=N) { log('착수 거부: 범위 밖', {x,y}); return; }

        const movesNow = normMoves(gameCache.moves);
        if (movesNow.some(m=>m.x===x && m.y===y)) { log('착수 거부: 중복 위치'); return; }

        const myC = myColor();
        const roomRef = ref(db, `rooms/${currentRoomId}`);
        const now = Date.now();

        let r1;
        try {
          r1 = await runTransaction(child(roomRef, 'moves'), (curr)=>{
            const arr = normMoves(curr);
            if (arr.some(m=>m.x===x && m.y===y)) return arr;
            arr.push({ x, y, color: myC, uid: me.uid, ts: now });
            return arr;
          });
        } catch (err) { console.error('moves 트랜잭션 실패', err); alert('착수 저장 실패: '+(err?.message||err)); return; }
        if (!r1?.committed) { log('moves 커밋 안됨'); return; }

        try {
          await runTransaction(roomRef, (room)=>{
            if(!room) return room;
            const moves2 = normMoves(room.moves);
            const last = moves2[moves2.length-1];
            const win = last ? checkWinLocal({moves:moves2}, last.x, last.y, last.color) : false;

            const now2 = Date.now();
            const elapsed2 = Math.max(0, now2 - (room.lastTurnTs || now2));
            if(room.turn==='B') room.timeB = Math.max(0, (room.timeB||0) - elapsed2 + (win?0:(room.incMs||0)));
            else room.timeW = Math.max(0, (room.timeW||0) - elapsed2 + (win?0:(room.incMs||0)));

            if (win) {
              room.status = 'ended';
              room.winner = last.color;
            } else {
              room.turn = (room.turn==='B' ? 'W' : 'B');
              room.lastTurnTs = now2;
              if(room.timeB<=0) { room.status='ended'; room.winner='W'; }
              if(room.timeW<=0) { room.status='ended'; room.winner='B'; }
            }
            return room;
          });
        } catch (err) { console.error('턴 전환 실패', err); alert('턴 업데이트 실패: '+(err?.message||err)); }
      }catch(err){ console.error(err); }
    });

    // 승리 판정 (마지막 수 기준 5목)
    function checkWinLocal(state, x, y, color){
      const moves = normMoves(state.moves);
      const grid = Array.from({length:N},()=>Array(N).fill(null));
      for(const m of moves){ grid[m.y][m.x] = m.color; }
      const dirs = [[1,0],[0,1],[1,1],[1,-1]];
      const inside = (xx,yy)=> xx>=0&&xx<N&&yy>=0&&yy<N;
      for(const [dx,dy] of dirs){
        let cnt=1;
        for(let s=1;s<5;s++){ const xx=x+dx*s, yy=y+dy*s; if(!inside(xx,yy)||grid[yy][xx]!==color) break; cnt++; }
        for(let s=1;s<5;s++){ const xx=x-dx*s, yy=y-dy*s; if(!inside(xx,yy)||grid[yy][xx]!==color) break; cnt++; }
        if(cnt>=5) return true;
      }
      return false;
    }

    // ====== 방 생성/참가/빠른 참가/관전/퇴장 ======
    btnCreate.addEventListener('click', async ()=>{
      const rid = (roomIdInput.value||'').trim(); if(!rid) return alert('방 ID를 입력하세요');
      if(!me.uid) return alert('로그인 완료를 기다려주세요');
      spectatorMode = false;
      currentRoomId = rid; roomLabelEl.textContent = rid;
      const roomRef = ref(db, `rooms/${rid}`);

      try{
        await set(roomRef, {
          gameId: rid,
          hostUid: me.uid,
          guestUid: null,
          status: 'waiting',
          turn: 'B',
          winner: null,
          moves: [],
          timeB: 300000,
          timeW: 300000,
          incMs: 10000,
          lastTurnTs: Date.now(),
          resultCommitted: false
        });
      }catch(err){ alert('방 생성 실패: '+(err?.message||err)); return; }

      await setupPresence(rid);
      attachRoomListener(rid);
      updateStatusUI();
      loadRatings();
    });

    btnJoin.addEventListener('click', async ()=>{
      const rid = (roomIdInput.value||'').trim(); if(!rid) return alert('방 ID를 입력하세요');
      if(!me.uid) return alert('로그인 완료를 기다려주세요');
      spectatorMode = false;
      await joinRoomById(rid);
    });

    btnQuick.addEventListener('click', async ()=>{
      if(!me.uid) return alert('로그인 완료를 기다려주세요');
      spectatorMode = false;
      try{
        const q = query(ref(db, 'rooms'), orderByChild('status'), equalTo('waiting'));
        const snap = await get(q);
        const list = [];
        snap.forEach(cs=>{ const v=cs.val(); if(v && !v.guestUid && v.hostUid!==me.uid) list.push({id:cs.key, ...v}); });
        if(list.length>0){
          const pick = list[Math.floor(Math.random()*list.length)];
          await joinRoomById(pick.gameId || pick.id);
          return;
        }
      }catch(e){ console.warn('대기 방 검색 실패', e); }
      const newId = 'r-' + Math.random().toString(36).slice(2,8);
      roomIdInput.value = newId;
      btnCreate.click();
    });

    btnWatch.addEventListener('click', async ()=>{
      const rid = (watchIdInput.value||'').trim(); if(!rid) return alert('관전할 방 ID 입력');
      await watchRoomById(rid);
    });

    btnRefreshWatch.addEventListener('click', async ()=>{
      await refreshWatchRooms();
    });

    watchBody.addEventListener('click', async (e)=>{
      const btn = e.target.closest('[data-watch]');
      if(btn){ const rid = btn.getAttribute('data-watch'); await watchRoomById(rid); }
    });

    async function joinRoomById(rid){
      currentRoomId = rid; roomLabelEl.textContent = rid;
      const roomRef = ref(db, `rooms/${rid}`);
      try{
        await runTransaction(roomRef, (room)=>{
          if(!room) return room; // 호스트가 먼저 생성
          if(room.hostUid === me.uid) return room; // 같은 UID 방지
          if(!room.guestUid){
            room.guestUid = me.uid; 
            room.status = 'playing'; 
            room.turn = 'B';
            room.lastTurnTs = Date.now();
          }
          return room;
        });
      }catch(err){ alert('방 참가 실패: '+(err?.message||err)); return; }

      await setupPresence(rid);
      attachRoomListener(rid);
      updateStatusUI();
      loadRatings();
    }

    async function watchRoomById(rid){
      spectatorMode = true; resultCommittedLocal = false; // 관전은 결과 반영 안 함
      currentRoomId = rid; roomLabelEl.textContent = rid;
      detachRoomListener(); // 기존 리스너 정리
      attachRoomListener(rid);
      updateStatusUI();
      // 관전은 presence 등록/ratings 조작 없음
    }

    btnLeave.addEventListener('click', async ()=>{
      if(!currentRoomId) return;
      detachRoomListener();
      if(presenceRef){ try{ await set(presenceRef, null); }catch{} }
      currentRoomId = null; presenceRef = null; resultCommittedLocal = false; spectatorMode = false;
      gameCache = { gameId:null, hostUid:null, guestUid:null, status:'waiting', turn:'B', winner:null, moves:[], timeB:300000, timeW:300000, incMs:10000, lastTurnTs:null, resultCommitted:false };
      updateStatusUI();
    });

    async function setupPresence(rid){
      try{
        presenceRef = ref(db, `presence/${rid}/${me.uid}`);
        await set(presenceRef, { ts: serverTimestamp() });
        onDisconnect(presenceRef).remove();

        const presRoomRef = ref(db, `presence/${rid}`);
        onValue(presRoomRef, async (snap)=>{
          const val = snap.val()||{}; const count = Object.keys(val).length;
          if(count>=2){
            const roomRef = ref(db, `rooms/${rid}`);
            try{
              await runTransaction(roomRef, (room)=>{
                if(!room) return room;
                if(room.status!=='playing' && room.hostUid===me.uid && room.guestUid){ room.status='playing'; room.lastTurnTs = Date.now(); }
                return room;
              });
            }catch(err){ console.warn('presence 기반 자동 시작 실패', err); }
          }
        });
      }catch(err){ console.warn('presence 설정 실패', err); }
    }

    function attachRoomListener(rid){
      const roomRef = ref(db, `rooms/${rid}`);
      if(roomUnsub) roomUnsub();
      roomUnsub = onValue(roomRef, async (snap)=>{
        const r = snap.val();
        if(!r){
          gameCache = { gameId:null, hostUid:null, guestUid:null, status:'waiting', turn:'B', winner:null, moves:[], timeB:300000, timeW:300000, incMs:10000, lastTurnTs:null, resultCommitted:false };
          log('방이 삭제되었습니다');
        }else{
          gameCache = { gameId:null, hostUid:null, guestUid:null, status:'waiting', turn:'B', winner:null, moves:[], timeB:300000, timeW:300000, incMs:10000, lastTurnTs:null, resultCommitted:false, ...r };
        }
        updateStatusUI();

        if(!spectatorMode && gameCache.status==='ended' && gameCache.winner && !resultCommittedLocal){
          try{ await commitResultOnce(rid); resultCommittedLocal = true; await refreshLeaderboard(); }catch(e){ console.warn('결과 커밋 실패', e); }
        }
      }, (err)=>{
        console.error('room listener error', err);
        log('room listener error', err?.message||String(err));
      });
    }

    function detachRoomListener(){ if(roomUnsub){ roomUnsub(); roomUnsub=null; } }

    // ====== 타이머 & 레이팅 & 관전 유틸 ======
    function msToClock(ms){
      const s = Math.max(0, Math.floor(ms/1000));
      const m = Math.floor(s/60), ss = s%60;
      return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    }

    function startOrUpdateTick(){
      if(tickTimer) return;
      tickTimer = setInterval(()=>{
        const r = gameCache;
        let tB = r.timeB||0, tW = r.timeW||0;
        if(r.status==='playing' && r.lastTurnTs){
          const elapsed = Date.now() - r.lastTurnTs;
          if(r.turn==='B') tB = Math.max(0, tB - elapsed);
          else tW = Math.max(0, tW - elapsed);
        }
        timeBEl.textContent = msToClock(tB);
        timeWEl.textContent = msToClock(tW);
      }, 200);
    }

    async function loadRatings(){
      if(!me.uid) return;
      try{
        const myRef = ref(db, `ratings/${me.uid}`);
        const host = gameCache.hostUid, guest = gameCache.guestUid;
        await update(myRef, { rating: 1000, games: 0, wins: 0, losses: 0 });
        const oppUid = (me.uid===host? guest : host);
        if(oppUid){ await update(ref(db, `ratings/${oppUid}`), { rating: 1000, games: 0, wins: 0, losses: 0 }); }
        myRatingEl.textContent = '1000+';
        oppRatingEl.textContent = oppUid? '1000+' : '—';
      }catch(e){ console.warn('레이팅 로드 실패', e); }
      refreshLeaderboard();
    }

    async function commitResultOnce(rid){
      const roomRef = ref(db, `rooms/${rid}`);
      const t = await runTransaction(child(roomRef,'resultCommitted'), (v)=> v? v : true);
      if(!t.committed) return; // 이미 반영됨

      const host = gameCache.hostUid, guest = gameCache.guestUid; if(!host||!guest) return;
      const winnerUid = (gameCache.winner==='B'? host : guest);
      const loserUid  = (gameCache.winner==='B'? guest : host);

      const K = 32;
      const getVal = async (r)=> new Promise(res=> onValue(r,s=>{ res(s.val()); }, {onlyOnce:true}));
      const wRef = ref(db, `ratings/${winnerUid}`);
      const lRef = ref(db, `ratings/${loserUid}`);
      const wData = (await getVal(wRef)) || { rating:1000, games:0, wins:0, losses:0 };
      const lData = (await getVal(lRef)) || { rating:1000, games:0, wins:0, losses:0 };
      const Ew = 1/(1+Math.pow(10, (lData.rating - wData.rating)/400));
      const El = 1 - Ew;
      const newW = Math.round(wData.rating + K*(1 - Ew));
      const newL = Math.round(lData.rating + K*(0 - El));
      await update(wRef, { rating:newW, games:(wData.games||0)+1, wins:(wData.wins||0)+1 });
      await update(lRef, { rating:newL, games:(lData.games||0)+1, losses:(lData.losses||0)+1 });
      if(me.uid===winnerUid) myRatingEl.textContent = String(newW);
      if(me.uid===loserUid)  myRatingEl.textContent = String(newL);
    }

    async function refreshLeaderboard(){
      try{
        const snap = await get(ref(db, 'ratings'));
        const arr = [];
        snap.forEach(cs=>{ const v=cs.val(); if(v && typeof v.rating==='number') arr.push({uid:cs.key, ...v}); });
        arr.sort((a,b)=> (b.rating||0)-(a.rating||0));
        const top = arr.slice(0,20);
        lbBody.innerHTML = top.map((r,i)=>{
          const W = r.wins||0, L = r.losses||0, G = r.games||0;
          return `<tr><td>${i+1}</td><td class="mono">${r.uid}</td><td>${r.rating}</td><td>${W}W-${L}L (${G})</td></tr>`;
        }).join('') || '<tr><td colspan="4" style="color:#9fbad1">데이터 없음</td></tr>';
      }catch(e){
        lbBody.innerHTML = `<tr><td colspan="4" style="color:#ef4444">리더보드 로드 실패: ${e?.message||e}</td></tr>`;
      }
    }

    async function refreshWatchRooms(){
      try{
        const q = query(ref(db,'rooms'), orderByChild('status'), equalTo('playing'));
        const snap = await get(q);
        const arr=[];
        snap.forEach(cs=>{ const v=cs.val(); if(v){ arr.push({id:cs.key, host:v.hostUid||'-', guest:v.guestUid||'-', moves: normMoves(v.moves).length, turn:v.turn||'-'}); }});
        arr.sort((a,b)=> (b.moves||0)-(a.moves||0));
        const top = arr.slice(0,30);
        watchBody.innerHTML = top.map(r=>`<tr>
          <td class="mono">${r.id}</td>
          <td class="mono">${r.host}</td>
          <td class="mono">${r.guest}</td>
          <td>${r.moves}</td>
          <td>${r.turn}</td>
          <td><button class="alt" data-watch="${r.id}">관전</button></td>
        </tr>`).join('') || '<tr><td colspan="6" style="color:#9fbad1">진행 중인 방이 없습니다</td></tr>';
      }catch(e){
        watchBody.innerHTML = `<tr><td colspan="6" style="color:#ef4444">관전 목록 실패: ${e?.message||e}</td></tr>`;
      }
    }

    // ====== 인증 ======
    signInAnonymously(auth).catch((e)=>{ console.error(e); alert('익명 로그인 실패: '+(e?.message||e)); });
    onAuthStateChanged(auth, (u)=>{
      if(!u) return; me.uid = u.uid; myUidEl.textContent = u.uid;
      btnCreate.disabled = false; btnJoin.disabled = false; btnQuick.disabled = false; btnWatch.disabled = false;
      refreshLeaderboard();
    });

    // 초기 렌더
    drawBoard();
  </script></body>
</html>

<!doctype html>

<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ì˜¤ëª© ëŒ€ê²° Â· Firebase Realtime DB (ë§¤ì¹˜ë©”ì´í‚¹ + ë ˆì´íŒ… ë¦¬ë”ë³´ë“œ + ê´€ì „)</title>
  <style>
    :root{
      --bg:#0f172a; --card:#111827; --muted:#93a6bf; --ring:#38bdf8; --accent:#22d3ee; --danger:#ef4444; --ok:#22c55e;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b1324,#0f172a 35%,#0b1324);font-family:system-ui,Segoe UI,Apple SD Gothic Neo,Pretendard,Arial,sans-serif;color:#e5e7eb}
    header{padding:16px 20px;border-bottom:1px solid #1f2937;background:#0b1324;position:sticky;top:0;z-index:10}
    h1{margin:0;font-size:18px;letter-spacing:.3px}
    .wrap{max-width:1280px;margin:0 auto;padding:20px;display:grid;grid-template-columns:420px 1fr;gap:20px}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .card .hd{padding:14px 16px;border-bottom:1px solid #1f2937;font-weight:600}
    .card .bd{padding:14px 16px}
    label{display:block;font-size:13px;color:var(--muted);margin:8px 0 6px}
    input,button{font:inherit}
    input[type=text]{width:100%;padding:10px 12px;border:1px solid #26405a;border-radius:10px;background:#0b1324;color:#e5e7eb}
    .row{display:flex;gap:8px;align-items:center}
    .row button{flex:1}
    button{cursor:pointer;border:none;padding:10px 12px;border-radius:10px;background:#0e7490;color:#e6f3f9}
    button.sec{background:#374151}
    button.alt{background:#2563eb}
    button:disabled{opacity:.5;cursor:not-allowed}
    .status{font-size:14px;line-height:1.4}
    .status .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #23405a;background:#0b1324;font-size:12px;color:#9ecfe6}
    canvas{background:#f4d9a2;border-radius:12px;display:block;width:100%;height:auto;image-rendering:-webkit-optimize-contrast}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .ok{color:var(--ok)} .danger{color:var(--danger)}
    .log{font-size:12px;color:#9fbad1;max-height:140px;overflow:auto;background:#0b1324;border:1px solid #1f2937;border-radius:10px;padding:8px}
    .timer{display:flex;gap:8px;margin-top:10px}
    .timer .clock{flex:1;background:#0b1324;border:1px solid #1f2937;border-radius:10px;padding:8px}
    .timer .clock h4{margin:0 0 6px 0;font-size:13px;color:#9fbad1}
    .big{font-size:20px;font-weight:700}
    .table{width:100%;border-collapse:collapse;font-size:14px}
    .table th,.table td{border-bottom:1px solid #1f2937;padding:8px;text-align:left}
    .table th{color:#9fbad1;font-weight:600}
  </style>
</head>
<body>
  <header>
    <h1>â™Ÿï¸ ì˜¤ëª© ëŒ€ê²° Â· Firebase (ë§¤ì¹˜ë©”ì´í‚¹ + ë¦¬ë”ë³´ë“œ + ê´€ì „)</h1>
  </header>
  <div class="wrap">
    <section class="card">
      <div class="hd">ì„¤ì • & ì—°ê²°</div>
      <div class="bd">
        <div class="grid">
          <div>
            <label>ë‚´ UID</label>
            <div id="myUid" class="mono">(ë¡œê·¸ì¸ ëŒ€ê¸°)</div>
          </div>
          <div>
            <label>í˜„ì¬ ë°© ID</label>
            <div id="roomLabel" class="mono">â€”</div>
          </div>
        </div>
        <label>ë°© ID</label>
        <div class="row">
          <input id="roomId" type="text" placeholder="ì˜ˆ: room-1234" />
          <button id="btnCreate" disabled>ë°© ë§Œë“¤ê¸°</button>
        </div>
        <div style="height:8px"></div>
        <div class="row">
          <button id="btnJoin" class="sec" disabled>ë°© ì°¸ê°€</button>
          <button id="btnQuick" class="alt" disabled>ë¹ ë¥¸ ì°¸ê°€</button>
          <button id="btnLeave" class="sec">ë‚˜ê°€ê¸°</button>
        </div>
        <div style="height:10px"></div>
        <div class="status" id="statusBox">
          ìƒíƒœ: <span class="pill" id="pill">ì´ˆê¸°í™”</span>
          <div style="height:6px"></div>
          <div>ì—­í• : <span id="role">â€”</span> / ëŒ ìƒ‰: <span id="color">â€”</span> / ë‚´ ì°¨ë¡€? <span id="turnQ">â€”</span></div>
          <div>í˜¸ìŠ¤íŠ¸: <span id="hostUid" class="mono">â€”</span></div>
          <div>ê²ŒìŠ¤íŠ¸: <span id="guestUid" class="mono">â€”</span></div>
        </div>
        <div style="height:12px"></div>
        <div class="log" id="log"></div>
      </div>
    </section><section class="card">
  <div class="hd">ëŒ€êµ­</div>
  <div class="bd">
    <canvas id="board" width="600" height="600"></canvas>
    <div class="timer">
      <div class="clock" id="clockB"><h4>í‘ ì‹œê°„</h4><div class="big" id="timeB">05:00</div></div>
      <div class="clock" id="clockW"><h4>ë°± ì‹œê°„</h4><div class="big" id="timeW">05:00</div></div>
    </div>
    <div style="height:8px"></div>
    <div class="grid">
      <div>
        <label>ë‚´ ë ˆì´íŒ…</label>
        <div class="mono" id="myRating">â€”</div>
      </div>
      <div>
        <label>ìƒëŒ€ ë ˆì´íŒ…</label>
        <div class="mono" id="oppRating">â€”</div>
      </div>
    </div>
  </div>
</section>

<section class="card">
  <div class="hd">ë ˆì´íŒ… ë¦¬ë”ë³´ë“œ (Top 20)</div>
  <div class="bd">
    <table class="table">
      <thead><tr><th>ìˆœìœ„</th><th>UID</th><th>ë ˆì´íŒ…</th><th>ì „ì </th></tr></thead>
      <tbody id="lbBody"><tr><td colspan="4" style="color:#9fbad1">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</td></tr></tbody>
    </table>
  </div>
</section>

<section class="card">
  <div class="hd">ê´€ì „ (ì§„í–‰ì¤‘ì¸ ë°©)</div>
  <div class="bd">
    <div class="row">
      <input id="watchId" type="text" placeholder="ë°© IDë¡œ ê´€ì „" />
      <button id="btnWatch" class="alt" disabled>ê´€ì „ ì‹œì‘</button>
      <button id="btnRefreshWatch" class="sec">ëª©ë¡ ìƒˆë¡œê³ ì¹¨</button>
    </div>
    <div style="height:8px"></div>
    <table class="table">
      <thead><tr><th>ë°© ID</th><th>í‘</th><th>ë°±</th><th>ìˆ˜</th><th>í„´</th><th></th></tr></thead>
      <tbody id="watchBody"><tr><td colspan="6" style="color:#9fbad1">ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° í´ë¦­</td></tr></tbody>
    </table>
  </div>
</section>

  </div>  <!-- Firebase v10 (modular) -->  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
    import { getDatabase, ref, child, set, update, onValue, runTransaction, onDisconnect, serverTimestamp, get, query, orderByChild, equalTo } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";

   const firebaseConfig = {
  apiKey: "AIzaSyCZe6mU-zN_pK1XgdLBXbl9gpiefM1zhT0",
  authDomain: "omok-d5f24.firebaseapp.com",
  databaseURL: "https://omok-d5f24-default-rtdb.firebaseio.com",
  projectId: "omok-d5f24",
  storageBucket: "omok-d5f24.firebasestorage.app",
  messagingSenderId: "913272245831",
  appId: "1:913272245831:web:3ae75841e0e97be832ab62",
  measurementId: "G-F713FYKGT5"
};

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    // ====== DOM ======
    const el = id => document.getElementById(id);
    const myUidEl = el('myUid');
    const roomLabelEl = el('roomLabel');
    const pillEl = el('pill');
    const roleEl = el('role');
    const colorEl = el('color');
    const turnQEl = el('turnQ');
    const hostUidEl = el('hostUid');
    const guestUidEl = el('guestUid');
    const roomIdInput = el('roomId');
    const btnCreate = el('btnCreate');
    const btnJoin = el('btnJoin');
    const btnQuick = el('btnQuick');
    const btnLeave = el('btnLeave');
    const canvas = el('board');
    const logBox = el('log');
    const lbBody = el('lbBody');
    const ctx = canvas.getContext('2d');
    const timeBEl = el('timeB');
    const timeWEl = el('timeW');
    const myRatingEl = el('myRating');
    const oppRatingEl = el('oppRating');
    const watchIdInput = el('watchId');
    const btnWatch = el('btnWatch');
    const btnRefreshWatch = el('btnRefreshWatch');
    const watchBody = el('watchBody');

    // ====== ìƒíƒœ ======
    const N = 15;                       // ë³´ë“œ í¬ê¸°
    const CELL = canvas.width / (N + 1);// ì—¬ë°± í¬í•¨ ê°„ê²©
    let me = { uid: null };
    let currentRoomId = null;
    let roomUnsub = null;    // onValue off ìš©
    let presenceRef = null;
    let resultCommittedLocal = false;   // ë ˆì´íŒ… ì¤‘ë³µ ì»¤ë°‹ ë°©ì§€
    let tickTimer = null;               // ì‹œê³„ í‘œì‹œ íƒ€ì´ë¨¸
    let spectatorMode = false;          // ê´€ì „ ëª¨ë“œ on/off

    // í´ë¼ì´ì–¸íŠ¸ ìºì‹œ (ìŠ¤ëƒ…ìƒ· ë³‘í•© ì‹œ ê¸°ë³¸ê°’ ë³´ì¥)
    let gameCache = {
      gameId: null,
      hostUid: null,
      guestUid: null,
      status: 'waiting', // waiting | playing | ended
      turn: 'B',         // 'B' (í‘) / 'W' (ë°±)
      winner: null,
      moves: [],
      // íƒ€ì´ë¨¸/ë ˆì´íŒ…
      timeB: 300000, // 5ë¶„
      timeW: 300000,
      incMs: 10000,  // ë§¤ ìˆ˜ 10ì´ˆ ì¦ê°€
      lastTurnTs: null,
      resultCommitted: false
    };

    const normMoves = (raw) => {
      if (Array.isArray(raw)) return raw.filter(Boolean);
      if (raw && typeof raw === 'object') return Object.values(raw).filter(Boolean);
      return [];
    };

    const log = (...a)=>{ const s=a.map(x=> typeof x==='string'?x:JSON.stringify(x)).join(' '); logBox.textContent = (s+''+logBox.textContent).slice(0,4000); };

    // ====== ìœ í‹¸ ======
    const setPill = (text, cls) => { pillEl.textContent = text; pillEl.className = 'pill ' + (cls||''); };
    const myRole = () => spectatorMode ? 'SPECTATOR' : (me.uid && gameCache.hostUid === me.uid) ? 'HOST' : (me.uid && gameCache.guestUid === me.uid) ? 'GUEST' : '-';
    const myColor = () => (myRole()==='HOST') ? 'B' : (myRole()==='GUEST') ? 'W' : '-';
    const isMyTurn = () => !spectatorMode && gameCache.status==='playing' && myColor() === gameCache.turn;

    // ====== ë Œë”ë§ ======
    function drawBoard(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#f4d9a2';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.strokeStyle = '#7c5c2c';
      ctx.lineWidth = 1;
      for(let i=1;i<=N;i++){
        ctx.beginPath(); ctx.moveTo(CELL, i*CELL); ctx.lineTo(N*CELL, i*CELL); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(i*CELL, CELL); ctx.lineTo(i*CELL, N*CELL); ctx.stroke();
      }

      const stars = [4,8,12];
      ctx.fillStyle = '#5b4630';
      stars.forEach(r=>stars.forEach(c=>{ ctx.beginPath(); ctx.arc(c*CELL, r*CELL, 3, 0, Math.PI*2); ctx.fill(); }));

      const moves = normMoves(gameCache?.moves);
      for(const m of moves){ if(!m) continue; drawStone(m.x, m.y, m.color); }
    }

    function drawStone(x,y,color){
      const cx = (x+1)*CELL, cy = (y+1)*CELL;
      ctx.beginPath();
      ctx.arc(cx, cy, CELL*0.42, 0, Math.PI*2);
      const grad = ctx.createRadialGradient(cx-4, cy-6, CELL*0.05, cx, cy, CELL*0.45);
      if(color==='B') { grad.addColorStop(0,'#333'); grad.addColorStop(1,'#000'); }
      else { grad.addColorStop(0,'#fff'); grad.addColorStop(1,'#c9c9c9'); }
      ctx.fillStyle = grad; ctx.fill();
      ctx.strokeStyle = '#00000055'; ctx.lineWidth = 1; ctx.stroke();
    }

    function updateStatusUI(){
      roomLabelEl.textContent = currentRoomId ?? 'â€”';
      hostUidEl.textContent = gameCache.hostUid ?? 'â€”';
      guestUidEl.textContent = gameCache.guestUid ?? 'â€”';
      roleEl.textContent = myRole();
      colorEl.textContent = myColor();
      turnQEl.textContent = isMyTurn()? 'âœ… ë„¤ ì°¨ë¡€' : (spectatorMode? 'ğŸ‘€ ê´€ì „' : 'â³ ëŒ€ê¸°');

      if(gameCache.status==='waiting') setPill(spectatorMode?'ëŒ€ê¸°(ê´€ì „)':'ëŒ€êµ­ ëŒ€ê¸°','');
      else if(gameCache.status==='playing') setPill(spectatorMode?'ì§„í–‰ ì¤‘(ê´€ì „)':'ì§„í–‰ ì¤‘','ok');
      else if(gameCache.status==='ended') setPill(`ì¢…ë£Œ (${gameCache.winner? (gameCache.winner==='B'?'í‘':'ë°±')+' ìŠ¹':''})`,'danger');

      drawBoard();
      startOrUpdateTick();
    }

    // í´ë¦­ â†’ ì°©ìˆ˜ (ê´€ì „ ì°¨ë‹¨ + ìŠ¤ëƒ… + ì—ëŸ¬ í‘œì¶œ + íƒ€ì´ë¨¸ ë°˜ì˜)
    canvas.addEventListener('click', async (e)=>{
      try{
        if(currentRoomId==null) return;
        if(spectatorMode){ log('ì°©ìˆ˜ ê±°ë¶€: ê´€ì „ ëª¨ë“œ'); return; }
        if(gameCache.status!=='playing') { log('ì°©ìˆ˜ ê±°ë¶€: ì§„í–‰ ìƒíƒœ ì•„ë‹˜'); return; }
        if(!isMyTurn()) { log('ì°©ìˆ˜ ê±°ë¶€: ë‚´ ì°¨ë¡€ ì•„ë‹˜'); return; }

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width  / rect.width;
        const scaleY = canvas.height / rect.height;
        const cx = (e.clientX - rect.left) * scaleX;
        const cy = (e.clientY - rect.top)  * scaleY;

        const gx = Math.round(cx / CELL);
        const gy = Math.round(cy / CELL);
        const x = gx - 1;
        const y = gy - 1;
        if (x<0 || x>=N || y<0 || y>=N) { log('ì°©ìˆ˜ ê±°ë¶€: ë²”ìœ„ ë°–', {x,y}); return; }

        const movesNow = normMoves(gameCache.moves);
        if (movesNow.some(m=>m.x===x && m.y===y)) { log('ì°©ìˆ˜ ê±°ë¶€: ì¤‘ë³µ ìœ„ì¹˜'); return; }

        const myC = myColor();
        const roomRef = ref(db, `rooms/${currentRoomId}`);
        const now = Date.now();

        let r1;
        try {
          r1 = await runTransaction(child(roomRef, 'moves'), (curr)=>{
            const arr = normMoves(curr);
            if (arr.some(m=>m.x===x && m.y===y)) return arr;
            arr.push({ x, y, color: myC, uid: me.uid, ts: now });
            return arr;
          });
        } catch (err) { console.error('moves íŠ¸ëœì­ì…˜ ì‹¤íŒ¨', err); alert('ì°©ìˆ˜ ì €ì¥ ì‹¤íŒ¨: '+(err?.message||err)); return; }
        if (!r1?.committed) { log('moves ì»¤ë°‹ ì•ˆë¨'); return; }

        try {
          await runTransaction(roomRef, (room)=>{
            if(!room) return room;
            const moves2 = normMoves(room.moves);
            const last = moves2[moves2.length-1];
            const win = last ? checkWinLocal({moves:moves2}, last.x, last.y, last.color) : false;

            const now2 = Date.now();
            const elapsed2 = Math.max(0, now2 - (room.lastTurnTs || now2));
            if(room.turn==='B') room.timeB = Math.max(0, (room.timeB||0) - elapsed2 + (win?0:(room.incMs||0)));
            else room.timeW = Math.max(0, (room.timeW||0) - elapsed2 + (win?0:(room.incMs||0)));

            if (win) {
              room.status = 'ended';
              room.winner = last.color;
            } else {
              room.turn = (room.turn==='B' ? 'W' : 'B');
              room.lastTurnTs = now2;
              if(room.timeB<=0) { room.status='ended'; room.winner='W'; }
              if(room.timeW<=0) { room.status='ended'; room.winner='B'; }
            }
            return room;
          });
        } catch (err) { console.error('í„´ ì „í™˜ ì‹¤íŒ¨', err); alert('í„´ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: '+(err?.message||err)); }
      }catch(err){ console.error(err); }
    });

    // ìŠ¹ë¦¬ íŒì • (ë§ˆì§€ë§‰ ìˆ˜ ê¸°ì¤€ 5ëª©)
    function checkWinLocal(state, x, y, color){
      const moves = normMoves(state.moves);
      const grid = Array.from({length:N},()=>Array(N).fill(null));
      for(const m of moves){ grid[m.y][m.x] = m.color; }
      const dirs = [[1,0],[0,1],[1,1],[1,-1]];
      const inside = (xx,yy)=> xx>=0&&xx<N&&yy>=0&&yy<N;
      for(const [dx,dy] of dirs){
        let cnt=1;
        for(let s=1;s<5;s++){ const xx=x+dx*s, yy=y+dy*s; if(!inside(xx,yy)||grid[yy][xx]!==color) break; cnt++; }
        for(let s=1;s<5;s++){ const xx=x-dx*s, yy=y-dy*s; if(!inside(xx,yy)||grid[yy][xx]!==color) break; cnt++; }
        if(cnt>=5) return true;
      }
      return false;
    }

    // ====== ë°© ìƒì„±/ì°¸ê°€/ë¹ ë¥¸ ì°¸ê°€/ê´€ì „/í‡´ì¥ ======
    btnCreate.addEventListener('click', async ()=>{
      const rid = (roomIdInput.value||'').trim(); if(!rid) return alert('ë°© IDë¥¼ ì…ë ¥í•˜ì„¸ìš”');
      if(!me.uid) return alert('ë¡œê·¸ì¸ ì™„ë£Œë¥¼ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”');
      spectatorMode = false;
      currentRoomId = rid; roomLabelEl.textContent = rid;
      const roomRef = ref(db, `rooms/${rid}`);

      try{
        await set(roomRef, {
          gameId: rid,
          hostUid: me.uid,
          guestUid: null,
          status: 'waiting',
          turn: 'B',
          winner: null,
          moves: [],
          timeB: 300000,
          timeW: 300000,
          incMs: 10000,
          lastTurnTs: Date.now(),
          resultCommitted: false
        });
      }catch(err){ alert('ë°© ìƒì„± ì‹¤íŒ¨: '+(err?.message||err)); return; }

      await setupPresence(rid);
      attachRoomListener(rid);
      updateStatusUI();
      loadRatings();
    });

    btnJoin.addEventListener('click', async ()=>{
      const rid = (roomIdInput.value||'').trim(); if(!rid) return alert('ë°© IDë¥¼ ì…ë ¥í•˜ì„¸ìš”');
      if(!me.uid) return alert('ë¡œê·¸ì¸ ì™„ë£Œë¥¼ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”');
      spectatorMode = false;
      await joinRoomById(rid);
    });

    btnQuick.addEventListener('click', async ()=>{
      if(!me.uid) return alert('ë¡œê·¸ì¸ ì™„ë£Œë¥¼ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”');
      spectatorMode = false;
      try{
        const q = query(ref(db, 'rooms'), orderByChild('status'), equalTo('waiting'));
        const snap = await get(q);
        const list = [];
        snap.forEach(cs=>{ const v=cs.val(); if(v && !v.guestUid && v.hostUid!==me.uid) list.push({id:cs.key, ...v}); });
        if(list.length>0){
          const pick = list[Math.floor(Math.random()*list.length)];
          await joinRoomById(pick.gameId || pick.id);
          return;
        }
      }catch(e){ console.warn('ëŒ€ê¸° ë°© ê²€ìƒ‰ ì‹¤íŒ¨', e); }
      const newId = 'r-' + Math.random().toString(36).slice(2,8);
      roomIdInput.value = newId;
      btnCreate.click();
    });

    btnWatch.addEventListener('click', async ()=>{
      const rid = (watchIdInput.value||'').trim(); if(!rid) return alert('ê´€ì „í•  ë°© ID ì…ë ¥');
      await watchRoomById(rid);
    });

    btnRefreshWatch.addEventListener('click', async ()=>{
      await refreshWatchRooms();
    });

    watchBody.addEventListener('click', async (e)=>{
      const btn = e.target.closest('[data-watch]');
      if(btn){ const rid = btn.getAttribute('data-watch'); await watchRoomById(rid); }
    });

    async function joinRoomById(rid){
      currentRoomId = rid; roomLabelEl.textContent = rid;
      const roomRef = ref(db, `rooms/${rid}`);
      try{
        await runTransaction(roomRef, (room)=>{
          if(!room) return room; // í˜¸ìŠ¤íŠ¸ê°€ ë¨¼ì € ìƒì„±
          if(room.hostUid === me.uid) return room; // ê°™ì€ UID ë°©ì§€
          if(!room.guestUid){
            room.guestUid = me.uid; 
            room.status = 'playing'; 
            room.turn = 'B';
            room.lastTurnTs = Date.now();
          }
          return room;
        });
      }catch(err){ alert('ë°© ì°¸ê°€ ì‹¤íŒ¨: '+(err?.message||err)); return; }

      await setupPresence(rid);
      attachRoomListener(rid);
      updateStatusUI();
      loadRatings();
    }

    async function watchRoomById(rid){
      spectatorMode = true; resultCommittedLocal = false; // ê´€ì „ì€ ê²°ê³¼ ë°˜ì˜ ì•ˆ í•¨
      currentRoomId = rid; roomLabelEl.textContent = rid;
      detachRoomListener(); // ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
      attachRoomListener(rid);
      updateStatusUI();
      // ê´€ì „ì€ presence ë“±ë¡/ratings ì¡°ì‘ ì—†ìŒ
    }

    btnLeave.addEventListener('click', async ()=>{
      if(!currentRoomId) return;
      detachRoomListener();
      if(presenceRef){ try{ await set(presenceRef, null); }catch{} }
      currentRoomId = null; presenceRef = null; resultCommittedLocal = false; spectatorMode = false;
      gameCache = { gameId:null, hostUid:null, guestUid:null, status:'waiting', turn:'B', winner:null, moves:[], timeB:300000, timeW:300000, incMs:10000, lastTurnTs:null, resultCommitted:false };
      updateStatusUI();
    });

    async function setupPresence(rid){
      try{
        presenceRef = ref(db, `presence/${rid}/${me.uid}`);
        await set(presenceRef, { ts: serverTimestamp() });
        onDisconnect(presenceRef).remove();

        const presRoomRef = ref(db, `presence/${rid}`);
        onValue(presRoomRef, async (snap)=>{
          const val = snap.val()||{}; const count = Object.keys(val).length;
          if(count>=2){
            const roomRef = ref(db, `rooms/${rid}`);
            try{
              await runTransaction(roomRef, (room)=>{
                if(!room) return room;
                if(room.status!=='playing' && room.hostUid===me.uid && room.guestUid){ room.status='playing'; room.lastTurnTs = Date.now(); }
                return room;
              });
            }catch(err){ console.warn('presence ê¸°ë°˜ ìë™ ì‹œì‘ ì‹¤íŒ¨', err); }
          }
        });
      }catch(err){ console.warn('presence ì„¤ì • ì‹¤íŒ¨', err); }
    }

    function attachRoomListener(rid){
      const roomRef = ref(db, `rooms/${rid}`);
      if(roomUnsub) roomUnsub();
      roomUnsub = onValue(roomRef, async (snap)=>{
        const r = snap.val();
        if(!r){
          gameCache = { gameId:null, hostUid:null, guestUid:null, status:'waiting', turn:'B', winner:null, moves:[], timeB:300000, timeW:300000, incMs:10000, lastTurnTs:null, resultCommitted:false };
          log('ë°©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
        }else{
          gameCache = { gameId:null, hostUid:null, guestUid:null, status:'waiting', turn:'B', winner:null, moves:[], timeB:300000, timeW:300000, incMs:10000, lastTurnTs:null, resultCommitted:false, ...r };
        }
        updateStatusUI();

        if(!spectatorMode && gameCache.status==='ended' && gameCache.winner && !resultCommittedLocal){
          try{ await commitResultOnce(rid); resultCommittedLocal = true; await refreshLeaderboard(); }catch(e){ console.warn('ê²°ê³¼ ì»¤ë°‹ ì‹¤íŒ¨', e); }
        }
      }, (err)=>{
        console.error('room listener error', err);
        log('room listener error', err?.message||String(err));
      });
    }

    function detachRoomListener(){ if(roomUnsub){ roomUnsub(); roomUnsub=null; } }

    // ====== íƒ€ì´ë¨¸ & ë ˆì´íŒ… & ê´€ì „ ìœ í‹¸ ======
    function msToClock(ms){
      const s = Math.max(0, Math.floor(ms/1000));
      const m = Math.floor(s/60), ss = s%60;
      return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    }

    function startOrUpdateTick(){
      if(tickTimer) return;
      tickTimer = setInterval(()=>{
        const r = gameCache;
        let tB = r.timeB||0, tW = r.timeW||0;
        if(r.status==='playing' && r.lastTurnTs){
          const elapsed = Date.now() - r.lastTurnTs;
          if(r.turn==='B') tB = Math.max(0, tB - elapsed);
          else tW = Math.max(0, tW - elapsed);
        }
        timeBEl.textContent = msToClock(tB);
        timeWEl.textContent = msToClock(tW);
      }, 200);
    }

    async function loadRatings(){
      if(!me.uid) return;
      try{
        const myRef = ref(db, `ratings/${me.uid}`);
        const host = gameCache.hostUid, guest = gameCache.guestUid;
        await update(myRef, { rating: 1000, games: 0, wins: 0, losses: 0 });
        const oppUid = (me.uid===host? guest : host);
        if(oppUid){ await update(ref(db, `ratings/${oppUid}`), { rating: 1000, games: 0, wins: 0, losses: 0 }); }
        myRatingEl.textContent = '1000+';
        oppRatingEl.textContent = oppUid? '1000+' : 'â€”';
      }catch(e){ console.warn('ë ˆì´íŒ… ë¡œë“œ ì‹¤íŒ¨', e); }
      refreshLeaderboard();
    }

    async function commitResultOnce(rid){
      const roomRef = ref(db, `rooms/${rid}`);
      const t = await runTransaction(child(roomRef,'resultCommitted'), (v)=> v? v : true);
      if(!t.committed) return; // ì´ë¯¸ ë°˜ì˜ë¨

      const host = gameCache.hostUid, guest = gameCache.guestUid; if(!host||!guest) return;
      const winnerUid = (gameCache.winner==='B'? host : guest);
      const loserUid  = (gameCache.winner==='B'? guest : host);

      const K = 32;
      const getVal = async (r)=> new Promise(res=> onValue(r,s=>{ res(s.val()); }, {onlyOnce:true}));
      const wRef = ref(db, `ratings/${winnerUid}`);
      const lRef = ref(db, `ratings/${loserUid}`);
      const wData = (await getVal(wRef)) || { rating:1000, games:0, wins:0, losses:0 };
      const lData = (await getVal(lRef)) || { rating:1000, games:0, wins:0, losses:0 };
      const Ew = 1/(1+Math.pow(10, (lData.rating - wData.rating)/400));
      const El = 1 - Ew;
      const newW = Math.round(wData.rating + K*(1 - Ew));
      const newL = Math.round(lData.rating + K*(0 - El));
      await update(wRef, { rating:newW, games:(wData.games||0)+1, wins:(wData.wins||0)+1 });
      await update(lRef, { rating:newL, games:(lData.games||0)+1, losses:(lData.losses||0)+1 });
      if(me.uid===winnerUid) myRatingEl.textContent = String(newW);
      if(me.uid===loserUid)  myRatingEl.textContent = String(newL);
    }

    async function refreshLeaderboard(){
      try{
        const snap = await get(ref(db, 'ratings'));
        const arr = [];
        snap.forEach(cs=>{ const v=cs.val(); if(v && typeof v.rating==='number') arr.push({uid:cs.key, ...v}); });
        arr.sort((a,b)=> (b.rating||0)-(a.rating||0));
        const top = arr.slice(0,20);
        lbBody.innerHTML = top.map((r,i)=>{
          const W = r.wins||0, L = r.losses||0, G = r.games||0;
          return `<tr><td>${i+1}</td><td class="mono">${r.uid}</td><td>${r.rating}</td><td>${W}W-${L}L (${G})</td></tr>`;
        }).join('') || '<tr><td colspan="4" style="color:#9fbad1">ë°ì´í„° ì—†ìŒ</td></tr>';
      }catch(e){
        lbBody.innerHTML = `<tr><td colspan="4" style="color:#ef4444">ë¦¬ë”ë³´ë“œ ë¡œë“œ ì‹¤íŒ¨: ${e?.message||e}</td></tr>`;
      }
    }

    async function refreshWatchRooms(){
      try{
        const q = query(ref(db,'rooms'), orderByChild('status'), equalTo('playing'));
        const snap = await get(q);
        const arr=[];
        snap.forEach(cs=>{ const v=cs.val(); if(v){ arr.push({id:cs.key, host:v.hostUid||'-', guest:v.guestUid||'-', moves: normMoves(v.moves).length, turn:v.turn||'-'}); }});
        arr.sort((a,b)=> (b.moves||0)-(a.moves||0));
        const top = arr.slice(0,30);
        watchBody.innerHTML = top.map(r=>`<tr>
          <td class="mono">${r.id}</td>
          <td class="mono">${r.host}</td>
          <td class="mono">${r.guest}</td>
          <td>${r.moves}</td>
          <td>${r.turn}</td>
          <td><button class="alt" data-watch="${r.id}">ê´€ì „</button></td>
        </tr>`).join('') || '<tr><td colspan="6" style="color:#9fbad1">ì§„í–‰ ì¤‘ì¸ ë°©ì´ ì—†ìŠµë‹ˆë‹¤</td></tr>';
      }catch(e){
        watchBody.innerHTML = `<tr><td colspan="6" style="color:#ef4444">ê´€ì „ ëª©ë¡ ì‹¤íŒ¨: ${e?.message||e}</td></tr>`;
      }
    }

    // ====== ì¸ì¦ ======
    signInAnonymously(auth).catch((e)=>{ console.error(e); alert('ìµëª… ë¡œê·¸ì¸ ì‹¤íŒ¨: '+(e?.message||e)); });
    onAuthStateChanged(auth, (u)=>{
      if(!u) return; me.uid = u.uid; myUidEl.textContent = u.uid;
      btnCreate.disabled = false; btnJoin.disabled = false; btnQuick.disabled = false; btnWatch.disabled = false;
      refreshLeaderboard();
    });

    // ì´ˆê¸° ë Œë”
    drawBoard();
  </script></body>
</html>
